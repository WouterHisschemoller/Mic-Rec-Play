<link rel="import" href="bower_components/polymer/polymer-element.html">

<dom-module id="mic-rec-play">
    <template>
        <style>
            :host {
                display: block;
                height: 100px;
                width: 100px;
            }
            canvas {
                cursor: pointer;
            }
        </style>
        <canvas></canvas>
    </template>
    <script>

        class MicRecPlay extends Polymer.Element {

            static get is() {
                return 'mic-rec-play';
            }
            
            ready() {
                super.ready();
                this.initCanvas();
                this.initAudio();
            }
            
            initCanvas() {
                this.radius = 50;
                this.offColor = '#990000';
                this.recColor = '#cc0000';
                this.rdyColor = '#0000cc';
                this.doublePI = Math.PI * 2;
                this.canvas = this.shadowRoot.querySelector('canvas');
                this.canvas.height = this.radius * 2;
                this.canvas.width = this.radius * 2;
                this.cCtx = this.canvas.getContext('2d');
                this.draw();
            }
            
            initAudio() {
                this.aCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.bufferSize = 2 * this.aCtx.sampleRate;
                this.audioBuffer = this.aCtx.createBuffer(1, this.bufferSize, this.aCtx.sampleRate);
                this.bufferIndex = 0;
                this.isRecording = false;
                this.isInputLevel = false;
                
                let self = this;
                navigator.mediaDevices.getUserMedia({
                        audio: true
                    })
                    .then(function(stream) {
                        self.streamSrc = self.aCtx.createMediaStreamSource(stream);
                        self.scriptPocessor = self.aCtx.createScriptProcessor(1024, 1, 1);
                        self.scriptPocessor.connect(self.aCtx.destination);
                        self.scriptPocessor.onaudioprocess = function(e) {
                            self.onCaptureStream(e);
                        }
                        self.streamSrc.connect(self.scriptPocessor);
                    })
                    .catch(function(err) {
                        console.log(err.name, ': ', err.message); 
                    });
            }

            connectedCallback() {
                super.connectedCallback();
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                document.addEventListener('keydown', this.onKeyDown.bind(this));
                document.addEventListener('keyup', this.onKeyUp.bind(this));
            }

            disconnectedCallback() {
                super.disconnectedCallback();
                this.canvas.removeEventListener('mousedown', this.onMouseDown);
                this.canvas.removeEventListener('mouseup', this.onMouseUp);
                document.removeEventListener('keydown', this.onKeyDown);
                document.removeEventListener('keyup', this.onKeyUp);
            }
            
            onMouseDown(e) {
                // a short delay to avoid recording a possible mouse or trackpad click
                let self = this;
                setTimeout(function() {
                    self.bufferIndex = 0;
                    self.isRecording = true;
                    self.isInputLevel = false;
                    self.draw();
                }, 100);
            }
            
            onMouseUp(e) {
                this.isRecording = false;
                this.draw();
            }
            
            onKeyDown(e) {
                if (!this.bufferSourceNode) {
                    this.bufferSourceNode = this.aCtx.createBufferSource();
                    this.bufferSourceNode.buffer = this.audioBuffer;
                    this.bufferSourceNode.connect(this.aCtx.destination);
                    this.bufferSourceNode.start();
                }
            }
            
            onKeyUp(e) {
                if (this.bufferSourceNode) {
                    this.bufferSourceNode.stop();
                    this.bufferSourceNode = null;
                }
            }
            
            onCaptureStream(e) {
                if (this.isRecording) {
                    let inputArray = e.inputBuffer.getChannelData(0),
                        bufferArray = this.audioBuffer.getChannelData(0);
                    for (let i = 0, n = inputArray.length; i < n; i++) {
                        if (this.isInputLevel) {
                            if (this.bufferIndex < this.bufferSize) {
                                bufferArray[this.bufferIndex] = inputArray[i];
                                this.bufferIndex += 1;
                            } else {
                                this.isRecording = false;
                            }
                        } else {
                            // check for audio level treshold
                            if (inputArray[i] > 0.1) {
                                this.isInputLevel = true;
                            }
                        }
                        
                    }
                    console.log(this.bufferIndex);
                }
            }
            
            draw() {
                this.cCtx.fillStyle = this.isRecording ? this.recColor : this.offColor;
                this.cCtx.arc(this.radius, this.radius, this.radius, 0, this.doublePI, true);
                this.cCtx.fill();
                
            }
        }
        
        customElements.define(MicRecPlay.is, MicRecPlay);

    </script>
</dom-module>
